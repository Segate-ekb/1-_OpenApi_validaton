
////////////////////////////////////////////////////////////////////////////////
// ВалидаторПакетов  
////////////////////////////////////////////////////////////////////////////////
#Если ВнешнееСоединение Или Сервер Тогда
#Область ОписаниеПеременных
Перем ШаблонБазовойОшибки; // Базовый текст ошибки
Перем ШаблонПредупреждения; // Базовый текст предупреждения

Перем ЧастиАдресаДанных;  // Составляющие полного пути к валидируемым данным
#КонецОбласти

#Область ПрограммныйИнтерфейс

// Возвращает список ошибок модели данных.
//
// Параметры:
//  МодельДанных - Структура - Проверяемый объект.
//               - Массив   - Проверяемый объект.
//  ИмяСхемы     - Строка - Имя схемы данных из спецификации.
//  СпецификацияСтрокой - Строка - Спецификация OpenAPI 3.0 в формате JSON.
// 
// Возвращаемое значение:
//  Структура - Структура результата валидации. см.КонструкторРезультатВалидации 
//
Функция Валидировать(Знач МодельДанных, Знач ИмяСхемы, Знач СпецификацияСтрокой) Экспорт // BSLLS:Typo-off
	Спецификация = СпецификацияСтрокой;
	РезультатВалидации = КонструкторРезультатВалидации();
	СхемыДанныхСпецификации = ВалидаторПакетовПовтИсп.СхемыДанныхСпецификации(Спецификация);

	ИнициализироватьАдресДанных();
	УстановитьШаблоныСообщений();
	
	ПроверитьСвойствоПоСхеме(МодельДанных, ИмяСхемы, СхемыДанныхСпецификации, Ложь);

	РезультатВалидации.Результат = КоллекцияОшибокПустая();
	РезультатВалидации.Ошибки = Ошибки;

	Возврат РезультатВалидации;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции
Процедура ПроверитьСвойствоПоСхеме(ПроверяемоеЗначение, ИмяСхемы,
									ТекущийКонтекст,
									ОписаниеДополнительныхСвойств = Истина)
		
	ПроверяемаяСхема = ПолучитьПроверяемуюСхему(ИмяСхемы, ТекущийКонтекст);
	Если ПроверяемаяСхема = Неопределено Тогда
		// Это доп.свойство
		ПроверяемаяСхема = ПолучитьСхемуДополнительныхСвойств(ОписаниеДополнительныхСвойств, ИмяСхемы);
		
		Если Не ЗначениеЗаполнено(ПроверяемаяСхема) Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;

	ВыполнитьВалидациюДанных(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема);
КонецПроцедуры

Функция ПолучитьСхемуДополнительныхСвойств(ОписаниеДополнительныхСвойств, ИмяСвойства)
	
	Если ОписаниеДополнительныхСвойств = Ложь Тогда
		// Доп.свойства нельзя, но схему не нашли. Зафиксируем ошибку.
		ОшибкаОбъектНеДопускаетДополнительныхСвойств(ИмяСвойства);
		Возврат Неопределено;
	КонецЕсли;

	Если ОписаниеДополнительныхСвойств = Истина Тогда
		Возврат Неопределено;
	КонецЕсли;

	Возврат РазыменоватьСхему(ОписаниеДополнительныхСвойств);
КонецФункции

Процедура ВыполнитьВалидациюДанных(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема)
	Если ЭтоСложнаяСхема(ПроверяемаяСхема) Тогда
		ОбработатьСложнуюСхему(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема);
	Иначе
		ВалидироватьДанныеПоСхеме(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема);
	КонецЕсли;
	
	ОбработатьNot(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема);
КонецПроцедуры

Процедура ВалидироватьДанныеПоСхеме(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема) // BSLLS:Typo-off
	УстановитьШаблоныСообщений(ПроверяемаяСхема.Получить("description"));
	
	Если ПроверяемоеЗначение = Неопределено Или ПроверяемоеЗначение = Null Тогда
		Nullable = ПроверяемаяСхема.Получить("nullable");
		Если Не Nullable = Истина Тогда
			ОшибкаЗначениеНеМожетБытьNull(ИмяСхемы);
		КонецЕсли;
		
		Возврат;
	КонецЕсли;
	
	ТипонезависимыеПроверки(ПроверяемоеЗначение, ПроверяемаяСхема);
	Тип = ПроверяемаяСхема.Получить("type");
	Если Тип = Неопределено Тогда
		// Это anytype тут может быть все что угодно и это валидно.
		// см. https://swagger.io/docs/specification/v3_0/data-models/data-types/#any-type
		// Но для нас надо определиться какие проверки мы будем применять. Для этого найдем тип по типу значения.
		
		Тип = ПолучитьТипOpenApiПоЗначениюСвойства(ПроверяемоеЗначение);
	КонецЕсли;
    
	Если Тип = "string" Тогда
		ВалидироватьСтроку(ПроверяемоеЗначение, ПроверяемаяСхема);
	ИначеЕсли Тип = "number" Тогда
		ВалидироватьЧисло(ПроверяемоеЗначение, ПроверяемаяСхема);
	ИначеЕсли Тип = "integer" Тогда
		ВалидироватьЧисло(ПроверяемоеЗначение, ПроверяемаяСхема, Истина);
	ИначеЕсли Тип = "array" Тогда
		ВалидироватьМассив(ПроверяемоеЗначение, ПроверяемаяСхема);
	ИначеЕсли Тип = "object" Тогда
		ВалидироватьОбъект(ПроверяемоеЗначение, ПроверяемаяСхема);
	ИначеЕсли Тип = "boolean" Тогда
		ВалидироватьБулево(ПроверяемоеЗначение, ПроверяемаяСхема);
	ИначеЕсли Тип = Неопределено Тогда
		// Мы получили тип, который не умеем валидировать.
		ТекстОшибки = СтрШаблон("%1 Недопустимый тип значения <%2>. Список допустимых: <%3>;",
										ШаблонБазовойОшибки,
										ТипЗнч(ПроверяемоеЗначение),
										СтрСоединить(МассивДопустимыхТипов1с(), "; "));
		ЗаписьЖурналаРегистрации("ВалидаторПакетов", // BSLLS:Typo-off
										УровеньЖурналаРегистрации.Ошибка, , ,
										ТекстОшибки);
		ВызватьИсключение ТекстОшибки;
	Иначе
		ТекстОшибки = СтрШаблон("%1 Ошибка при разборе схемы! Задано некорректное значение типа в <%2>;",
										ШаблонБазовойОшибки,
										ИмяСхемы);
		ЗаписьЖурналаРегистрации("ВалидаторПакетов", // BSLLS:Typo-off
										УровеньЖурналаРегистрации.Ошибка, , ,
										ТекстОшибки);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
КонецПроцедуры

Функция ПолучитьМаппингДопустимыхТипов1сНаOpenApi()
	СоответствиеДопустимыхТипов = Новый Соответствие;
	OpenAPIСтрока = "string";
	СоответствиеДопустимыхТипов.Вставить(Тип("Строка"), OpenAPIСтрока);
	СоответствиеДопустимыхТипов.Вставить(Тип("Дата"), OpenAPIСтрока);
	СоответствиеДопустимыхТипов.Вставить(Тип("УникальныйИдентификатор"), OpenAPIСтрока);
	
	СоответствиеДопустимыхТипов.Вставить(Тип("Число"), "number");
	
	СоответствиеДопустимыхТипов.Вставить(Тип("Булево"), "boolean");
	
	СоответствиеДопустимыхТипов.Вставить(Тип("Массив"), "array");
	
	СоответствиеДопустимыхТипов.Вставить(Тип("Структура"), "object");
	СоответствиеДопустимыхТипов.Вставить(Тип("Соответствие"), "object");
	
	Возврат СоответствиеДопустимыхТипов;
КонецФункции

Функция ПолучитьТипOpenApiПоЗначениюСвойства(ПроверяемоеЗначение) // BSLLS:LatinAndCyrillicSymbolInWord-off
	СоответствиеДопустимыхТипов = ПолучитьМаппингДопустимыхТипов1сНаOpenApi();
	
	Возврат СоответствиеДопустимыхТипов.Получить(ТипЗнч(ПроверяемоеЗначение));
КонецФункции

Функция МассивДопустимыхТипов1с()
	СоответствиеДопустимыхТипов = ПолучитьМаппингДопустимыхТипов1сНаOpenApi();
	МассивТипов = Новый массив;
	Для Каждого ЭлементСоответствия Из СоответствиеДопустимыхТипов Цикл
		МассивТипов.Добавить(ЭлементСоответствия.Ключ);
	КонецЦикла;
	
	Возврат МассивТипов;
КонецФункции

#Область ОбщиеПроверки
Процедура ТипонезависимыеПроверки(ПроверяемоеЗначение, ПроверяемаяСхема) // BSLLS:Typo-off
	ПроверитьСоответствиеПеречислению(ПроверяемоеЗначение, ПроверяемаяСхема);
	ОбработатьDepricated(ПроверяемаяСхема);
КонецПроцедуры

Процедура ПроверитьСоответствиеПеречислению(ПроверяемоеЗначение, ПроверяемаяСхема)
	ЗначенияПеречисления = ПроверяемаяСхема.Получить("enum");
	Если ЗначенияПеречисления = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗначенияПеречисления.Найти(ПроверяемоеЗначение) = Неопределено Тогда
		ОшибкаЗначениеНеИзСпискаДопустимых(ПроверяемоеЗначение, ЗначенияПеречисления);
	КонецЕсли;
КонецПроцедуры

Процедура ОбработатьDepricated(ПроверяемаяСхема)
	Если Не ПроверяемаяСхема.Получить("deprecated") = Истина Тогда
		// Не depricated
		Возврат;
	КонецЕсли;

	ОшибкаОбъектСодержитУстаревшееСвойство();
КонецПроцедуры

#КонецОбласти

#Область РаботаСоСложнымиСхемами
Процедура ОбработатьСложнуюСхему(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема)
	Дискриминатор = ПроверяемаяСхема.Получить("discriminator");
	Если ЕстьСвойство("oneOf", ПроверяемаяСхема) Тогда
		ОбработатьСвойствоOneOf(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема.Получить("oneOf"), Дискриминатор);
	ИначеЕсли ЕстьСвойство("anyOf", ПроверяемаяСхема) Тогда
		ОбработатьСвойствоAnyOf(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема.Получить("anyOf"), Дискриминатор);
	ИначеЕсли ЕстьСвойство("allOf", ПроверяемаяСхема) Тогда
		ОбработатьСвойствоAllOf(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема.Получить("allOf"), Дискриминатор);
	Иначе
		// Тут такого быть категорически не должно! Это ошибка валидатора.
		ВызватьИсключение "Ошибка при разборе схемы! Не найдено ни одного из свойств oneOf, anyOf, allOf;";
	КонецЕсли;
КонецПроцедуры

Процедура ОбработатьСвойствоOneOf(ПроверяемоеЗначение, ИмяСхемы, МассивПроверяемыхСхем, Дискриминатор = Неопределено)
	МассивИндексовСхемПрошедшихВалидацию = Новый Массив;
		
	Для Индекс = 0 По МассивПроверяемыхСхем.ВГраница() Цикл
		ТекущаяСхема = МассивПроверяемыхСхем[Индекс];
		Если Не СхемаПодходитПоДискриминатору(ПроверяемоеЗначение, ТекущаяСхема, Дискриминатор) Тогда
			Продолжить;
		КонецЕсли;
		ПроверяемаяСхема = РазыменоватьСхему(ТекущаяСхема);
	    КэшОшибок = СпрятатьДиагностики();
		ВыполнитьВалидациюДанных(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема);
		Если КоллекцияОшибокПустая() Тогда
	    	МассивИндексовСхемПрошедшихВалидацию.Добавить(Индекс);
		КонецЕсли;
		ОчиститьКоллекциюДиагностик();
		ВосстановитьДиагностики(КэшОшибок);
		Если МассивИндексовСхемПрошедшихВалидацию.Количество() > 1 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если МассивИндексовСхемПрошедшихВалидацию.Количество() = 0 Тогда
		ОшибкаНесоответствиеСхемамOneOf();
	ИначеЕсли МассивИндексовСхемПрошедшихВалидацию.Количество() > 1 Тогда
		ОшибкаСоответствиеНесколькимСхемамOneOf(МассивИндексовСхемПрошедшихВалидацию);
	КонецЕсли;  // BSLLS:IfElseIfEndsWithElse-off
	
КонецПроцедуры

Процедура ОбработатьСвойствоAnyOf(ПроверяемоеЗначение, ИмяСхемы, МассивПроверяемыхСхем, Дискриминатор = Неопределено)
	МассивИндексовСхемПрошедшихВалидацию = Новый Массив;
	
	Для Индекс = 0 По МассивПроверяемыхСхем.ВГраница() Цикл
		ТекущаяСхема = МассивПроверяемыхСхем[Индекс];
		Если Не СхемаПодходитПоДискриминатору(ПроверяемоеЗначение, ТекущаяСхема, Дискриминатор) Тогда
			Продолжить;
		КонецЕсли;
		ПроверяемаяСхема = РазыменоватьСхему(ТекущаяСхема);
	    КэшОшибок = СпрятатьДиагностики();
		ВыполнитьВалидациюДанных(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема);
		Если КоллекцияОшибокПустая() Тогда
			МассивИндексовСхемПрошедшихВалидацию.Добавить(Индекс);
		КонецЕсли;
		ОчиститьКоллекциюДиагностик();
		ВосстановитьДиагностики(КэшОшибок);
		Если МассивИндексовСхемПрошедшихВалидацию.Количество() > 0 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если МассивИндексовСхемПрошедшихВалидацию.Количество() = 0 Тогда
		ОшибкаНесоответствиеСхемамAnyOf();
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьСвойствоAllOf(ПроверяемоеЗначение, ИмяСхемы, МассивПроверяемыхСхем, Дискриминатор = Неопределено)
	КэшОшибок = СпрятатьДиагностики();
	Для Индекс = 0 По МассивПроверяемыхСхем.ВГраница() Цикл
		ТекущаяСхема = МассивПроверяемыхСхем[Индекс];
		Если Не СхемаПодходитПоДискриминатору(ПроверяемоеЗначение, ТекущаяСхема, Дискриминатор) Тогда
			Продолжить;
		КонецЕсли;
		ПроверяемаяСхема = РазыменоватьСхему(ТекущаяСхема);
		
		ВыполнитьВалидациюДанных(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема);
	КонецЦикла;
	
	Если Не КоллекцияОшибокПустая() Тогда
		ОшибкаНесоответствиеСхемамAllOf();
	КонецЕсли;
	ВосстановитьДиагностики(КэшОшибок);
КонецПроцедуры

Процедура ОбработатьNot(ПроверяемоеЗначение, ИмяСхемы, ПроверяемаяСхема)
	Если Не ЕстьСвойство("not", ПроверяемаяСхема) Тогда
		Возврат;
	КонецЕсли;
	
	// Для обработки not, нам понадобятся промежуточные результаты валидации.
	// Закэшируем накопленные ошибки, а после выполнения проверок вернем их на место.
	КэшОшибок = СпрятатьДиагностики();
	
	ОтрицательнаяСхема = ПроверяемаяСхема.Получить("not");
	ОтрицательнаяСхема = РазыменоватьСхему(ОтрицательнаяСхема);
	
	ВалидироватьДанныеПоСхеме(ПроверяемоеЗначение, ИмяСхемы, ОтрицательнаяСхема);
	
	ВалидацияУспешная = КоллекцияОшибокПустая();
	ОчиститьКоллекциюДиагностик();
	ВосстановитьДиагностики(КэшОшибок);
	
	Если ВалидацияУспешная Тогда
		// Объект прошел валидацию по схеме, а не должен был.
		ОшибкаНесоответствиеСхемеNot();
	КонецЕсли;

КонецПроцедуры

Функция СхемаПодходитПоДискриминатору(ПроверяемоеЗначение, ТекущаяСхема, Дискриминатор)
	Если Дискриминатор = Неопределено Тогда
		// Дискриминатора нет, просто вернем истину.
		Возврат Истина;
	КонецЕсли;
			
	ИмяКлючевогоСвойства = Дискриминатор.Получить("propertyName");
	Если ТипЗнч(ПроверяемоеЗначение) = Тип("Структура") Тогда
		ЗначениеКлючевогоСвойства = Неопределено;
		ПроверяемоеЗначение.Свойство(ИмяКлючевогоСвойства, ЗначениеКлючевогоСвойства);
	ИначеЕсли ТипЗнч(ПроверяемоеЗначение) = Тип("Соответствие") Тогда
		ЗначениеКлючевогоСвойства = ПроверяемоеЗначение.Получить(ИмяКлючевогоСвойства);
	Иначе
		ЗначениеКлючевогоСвойства = Неопределено;
	КонецЕсли;
	
	Если ЗначениеКлючевогоСвойства = Неопределено Тогда
		ОшибкаНетЗначенияДискриминатора(ИмяКлючевогоСвойства);
		Возврат Ложь;
	КонецЕсли;

	СсылкаНаСхему = Неопределено;
	Маппинг = Дискриминатор.Получить("mapping");
	Если Не Маппинг = Неопределено Тогда
		СсылкаНаСхему = Маппинг.Получить(Строка(ЗначениеКлючевогоСвойства));
	КонецЕсли;
	Если СсылкаНаСхему = Неопределено Тогда
		СсылкаНаСхему = СтрШаблон("#/components/schemas/%1", ЗначениеКлючевогоСвойства);
	КонецЕсли;
	
	Возврат Не СсылкаНаСхему = Неопределено И СсылкаНаСхему = ТекущаяСхема.Получить("$ref");
КонецФункции

#КонецОбласти

#Область ВалидацияСтроки
Процедура ВалидироватьСтроку(ПроверяемоеЗначение, ПроверяемаяСхема)
	
	ОписаниеТипа = СоздатьОписаниеТиповПриПроверкеСтроки(ПроверяемаяСхема);
		
	Если Не ТипЗначенияСоответствуетОписанию(ПроверяемоеЗначение, ОписаниеТипа) Тогда
		Возврат;
	КонецЕсли;
	
	ПроверитьМинимальнуюДлину(ПроверяемоеЗначение, ПроверяемаяСхема);
	
	ПроверитьСтрокуНаСоответствиеФорматуИПаттерну(ПроверяемоеЗначение,
													ПроверяемаяСхема);
	ПроверитьСоответствиеПеречислению(ПроверяемоеЗначение, ПроверяемаяСхема);
КонецПроцедуры

Функция СоздатьОписаниеТиповПриПроверкеСтроки(ПроверяемаяСхема)
	ОписаниеТипа = Новый ОписаниеТипов("Строка");
	МаксимальнаяДлина = ПроверяемаяСхема.Получить("maxLength");
	Если Не МаксимальнаяДлина = Неопределено Тогда
		КвалификаторСтроки = Новый КвалификаторыСтроки(МаксимальнаяДлина);
		ОписаниеТипа = Новый ОписаниеТипов(ОписаниеТипа, , , , КвалификаторСтроки);
	КонецЕсли;
	Формат =  ПроверяемаяСхема.Получить("format");
	Если Формат = "date" Тогда
		КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты.Дата);
		ОписаниеТипа = Новый ОписаниеТипов(ОписаниеТипа, "Дата", , , , КвалификаторДаты);
	ИначеЕсли Формат = "date-time" Тогда
		КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
		ОписаниеТипа = Новый ОписаниеТипов(ОписаниеТипа, "Дата", , , , КвалификаторДаты);
	ИначеЕсли Формат = "uuid" Тогда
		ОписаниеТипа = Новый ОписаниеТипов(ОписаниеТипа, "УникальныйИдентификатор");
	КонецЕсли; // BSLLS:IfElseIfEndsWithElse-off
	
Возврат ОписаниеТипа;
КонецФункции

Процедура ПроверитьСтрокуНаСоответствиеФорматуИПаттерну(ПроверяемоеЗначение, ПроверяемаяСхема)
	ФорматЗначения = ПроверяемаяСхема.Получить("format");
	Паттерн = ПроверяемаяСхема.Получить("pattern");
// BSLLS:LineLength-off
	Если ФорматЗначения = "byte" Тогда
		ПроверитьBase64(ПроверяемоеЗначение);
	ИначеЕсли ФорматЗначения = "date" Тогда
		ПроверитьДату(ПроверяемоеЗначение, ЧастиДаты.Дата);
	ИначеЕсли ФорматЗначения = "date-time" Тогда
		ПроверитьДату(ПроверяемоеЗначение, ЧастиДаты.ДатаВремя);
	ИначеЕсли ФорматЗначения = "email" Тогда
		Паттерн = "^((?!\.)[\w\-_.]*[^.])(@\w+)(\.\w+(\.\w+)?[^.\W])$";
	ИначеЕсли ФорматЗначения = "uuid" Тогда
		Паттерн = "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}";
	ИначеЕсли ФорматЗначения = "uri" Тогда
		Паттерн = "^(((ht|f)tp(s?)\:\/\/[0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*(:(0-9)*)*))?(\/?)(\{?)([a-zA-Z0-9\-\.\?\,\'\/\\\+\~\{\}\&%\$#_]*)?(\}?)(\/?)$"; // BSLLS:LineLength-off
	ИначеЕсли ФорматЗначения = "ipv4" Тогда
		Паттерн = "^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
	ИначеЕсли ФорматЗначения = "ipv6" Тогда
		Паттерн = "^([[:xdigit:]]{1,4}(?::[[:xdigit:]]{1,4}){7}|::|:(?::[[:xdigit:]]{1,4}){1,6}|[[:xdigit:]]{1,4}:(?::[[:xdigit:]]{1,4}){1,5}|(?:[[:xdigit:]]{1,4}:){2}(?::[[:xdigit:]]{1,4}){1,4}|(?:[[:xdigit:]]{1,4}:){3}(?::[[:xdigit:]]{1,4}){1,3}|(?:[[:xdigit:]]{1,4}:){4}(?::[[:xdigit:]]{1,4}){1,2}|(?:[[:xdigit:]]{1,4}:){5}:[[:xdigit:]]{1,4}|(?:[[:xdigit:]]{1,4}:){1,6}:)$";
	Иначе
		ФорматЗначения = "pattern";
	КонецЕсли;
// BSLLS:LineLength-on
	Если ЗначениеЗаполнено(Паттерн) Тогда
		ПроверитьПоРегулярномуВыражению(ПроверяемоеЗначение, Паттерн, ФорматЗначения);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьДату(ПроверяемоеЗначение, ОписаниеЧастиДаты)
	ОписаниеДаты = Новый ОписаниеТипов("Дата", , , , , Новый КвалификаторыДаты(ОписаниеЧастиДаты));
	Попытка
		Дата = ПрочитатьДатуJSON(ПроверяемоеЗначение, ФорматДатыJSON.ISO);
		ПриведеннаяДата = ОписаниеДаты.ПривестиЗначение(Дата);
	Исключение
		ОшибкаСтрокаНеСоответствуетФорматуДаты(ОписаниеЧастиДаты);
		Возврат;
	КонецПопытки;
	
	Если Не Дата = ПриведеннаяДата Тогда
		ОшибкаСтрокаНеСоответствуетФорматуДаты(ОписаниеЧастиДаты);
		Возврат;
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьПоРегулярномуВыражению(ПроверяемоеЗначение, Паттерн, Формат)
	Если Не СтрПодобнаПоРегулярномуВыражению(ПроверяемоеЗначение, Паттерн) Тогда
		ОшибкаСтрокаНеСоответствуетШаблону(Формат);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьBase64(ПроверяемоеЗначение)
	Если Не ЗначениеЗаполнено(Base64Значение(ПроверяемоеЗначение)) Тогда
		ОшибкаСтрокаНеBase64();
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьМинимальнуюДлину(ПроверяемоеЗначение, ПроверяемаяСхема)
	МинимальнаяДлина = ПроверяемаяСхема.Получить("minLength");
	Если Не МинимальнаяДлина = Неопределено И СтрДлина(ПроверяемоеЗначение) < МинимальнаяДлина Тогда
		ОшибкаСтрокаСлишкомКороткая(МинимальнаяДлина);
	КонецЕсли;
КонецПроцедуры
#КонецОбласти

#Область ВалидацияЧисла
Процедура ВалидироватьЧисло(ПроверяемоеЗначение, ПроверяемаяСхема, Целое = Ложь) // BSLLS:Typo-off
	ОписаниеТипа = СоздатьОписаниеТиповПриПроверкеЧисла(Целое);
	
	Если Не ТипЗначенияСоответствуетОписанию(ПроверяемоеЗначение, ОписаниеТипа) Тогда
		Возврат;
	КонецЕсли;
		
	ПроверитьМинимум(ПроверяемоеЗначение, ПроверяемаяСхема);
	
	ПроверитьМаксимум(ПроверяемоеЗначение, ПроверяемаяСхема);
	
	ПроверитьКратность(ПроверяемоеЗначение, ПроверяемаяСхема);
	
	ПроверитьЧислоНаСоответствиеФормату(ПроверяемоеЗначение, ПроверяемаяСхема);
КонецПроцедуры

Функция СоздатьОписаниеТиповПриПроверкеЧисла(Целое = Ложь)
	ОписаниеТипа = Новый ОписаниеТипов("Число");
	Если Целое Тогда
		МаксимальнаяРазрядностьЧисла = 20;
		ОписаниеТипа = Новый ОписаниеТипов(ОписаниеТипа, , ,  Новый КвалификаторыЧисла(МаксимальнаяРазрядностьЧисла, 0));
	КонецЕсли;
	
	Возврат ОписаниеТипа;
КонецФункции

Процедура ПроверитьМинимум(ПроверяемоеЗначение, ПроверяемаяСхема)
	МинимальноеЗначение = ПроверяемаяСхема.Получить("minimum");
	Если  МинимальноеЗначение = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Включая = Не ПроверяемаяСхема.Получить("exclusiveMinimum") = Истина;
	Если ПроверяемоеЗначение < МинимальноеЗначение
		ИЛИ (Не Включая И МинимальноеЗначение = ПроверяемоеЗначение) Тогда
		ОшибкаЧислоСлишкомМало(ПроверяемоеЗначение, МинимальноеЗначение, Включая);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьМаксимум(ПроверяемоеЗначение, ПроверяемаяСхема)
	МаксимальноеЗначение = ПроверяемаяСхема.Получить("maximum");
	Если МаксимальноеЗначение = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Включая = Не ПроверяемаяСхема.Получить("exclusiveMaximum") = Истина;
	Если ПроверяемоеЗначение > МаксимальноеЗначение
		ИЛИ (Не Включая И МаксимальноеЗначение = ПроверяемоеЗначение) Тогда
		ОшибкаЧислоСлишкомБольшое(ПроверяемоеЗначение, МаксимальноеЗначение, Включая);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьКратность(ПроверяемоеЗначение, ПроверяемаяСхема)
	Кратность = ПроверяемаяСхема.Получить("multipleOf");
	Если Кратность = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Кратность = 0 Тогда
		ВызватьИсключение "Ошибка в схеме! Кратность не может быть равна нулю;";
	КонецЕсли;
		
	Если Не ПроверяемоеЗначение % Кратность = 0 Тогда
		ОшибкаЧислоНеКратно(ПроверяемоеЗначение, Кратность);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьЧислоНаСоответствиеФормату(ПроверяемоеЗначение, ПроверяемаяСхема)
	ФорматЗначения = ПроверяемаяСхема.Получить("format");
	Если ФорматЗначения = "int32" Тогда
		ПроверитьInt32(ПроверяемоеЗначение);
	ИначеЕсли ФорматЗначения = "int64" Тогда
		ПроверитьInt64(ПроверяемоеЗначение);
	КонецЕсли; // BSLLS:IfElseIfEndsWithElse-off
КонецПроцедуры

Процедура ПроверитьInt32(ПроверяемоеЗначение)
	НижняяГраницаЦелого = -2147483648;
	ВерхняяГраницаЦелого = 2147483647;
	Если ПроверяемоеЗначение < НижняяГраницаЦелого Или ПроверяемоеЗначение > ВерхняяГраницаЦелого Тогда
		ОшибкаЧислоНе32Битное(ПроверяемоеЗначение);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьInt64(ПроверяемоеЗначение)
	НижняяГраницаЦелого = -9223372036854775808;
	ВерхняяГраницаЦелого = 9223372036854775807;
	Если ПроверяемоеЗначение < НижняяГраницаЦелого Или ПроверяемоеЗначение > ВерхняяГраницаЦелого Тогда
		ОшибкаЧислоНе64Битное(ПроверяемоеЗначение);
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область ВалидацияМассива
Процедура ВалидироватьМассив(ПроверяемоеЗначение, ПроверяемаяСхема) // BSLLS:Typo-off
	ОписаниеТипа = Новый ОписаниеТипов("Массив");
	
	Если Не ТипЗначенияСоответствуетОписанию(ПроверяемоеЗначение, ОписаниеТипа) Тогда
		Возврат;
	КонецЕсли;
	
	ПроверитьМинимумИМаксимумСтрок(ПроверяемоеЗначение, ПроверяемаяСхема);
	
	ПроверитьУникальностьЗначений(ПроверяемоеЗначение, ПроверяемаяСхема);
	
	Для Индекс = 0 По ПроверяемоеЗначение.ВГраница() Цикл
		ЭлементМассива = ПроверяемоеЗначение[Индекс];
		АдресЭлемента = СтрШаблон("[%1]", Формат(Индекс, "ЧН=; ЧГ="));
		
		ДополнитьАдресДанных(АдресЭлемента);
		ПроверитьСвойствоПоСхеме(ЭлементМассива, "items", ПроверяемаяСхема, Ложь);
		СократитьАдресДанных();
	КонецЦикла;
КонецПроцедуры

Процедура ПроверитьМинимумИМаксимумСтрок(ПроверяемыйМассив, ПроверяемаяСхема)
	
	МинимумСтрок = ПроверяемаяСхема.Получить("minItems");
	Если Не МинимумСтрок = Неопределено И ПроверяемыйМассив.Количество() < МинимумСтрок Тогда
		ОшибкаМассивСлишкомКороткий(ПроверяемыйМассив, МинимумСтрок);
		Возврат;
	КонецЕсли;
	
	МаксимумСтрок = ПроверяемаяСхема.Получить("maxItems");
	Если Не МаксимумСтрок = Неопределено И ПроверяемыйМассив.Количество() > МаксимумСтрок Тогда
		ОшибкаМассивСлишкомДлинный(ПроверяемыйМассив, МаксимумСтрок);
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьУникальностьЗначений(ПроверяемыйМассив, ПроверяемаяСхема)
	УникальныеЗначения = ПроверяемаяСхема.Получить("uniqueItems");
	
	Если Не УникальныеЗначения = Истина Тогда
		Возврат;
	КонецЕсли;
	
	СвернутыйМассив =  СвернутьМассив(ПроверяемыйМассив);
	
	Если Не СвернутыйМассив.Количество() = ПроверяемыйМассив.Количество() Тогда
		ОшибкаМассивСНеуникальнымиЭлементами();
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область ВалидацияОбъекта
Процедура ВалидироватьОбъект(ПроверяемоеЗначение, ПроверяемаяСхема) // BSLLS:Typo-off
	ОписаниеТипа = Новый ОписаниеТипов("Структура,Соответствие");
	
	Если Не ТипЗначенияСоответствуетОписанию(ПроверяемоеЗначение, ОписаниеТипа) Тогда
		Возврат;
	КонецЕсли;
	
	ПроверитьНаличиеОбязательныхСвойств(ПроверяемоеЗначение, ПроверяемаяСхема);
	
	ПроверитьКоличествоСвойств(ПроверяемоеЗначение, ПроверяемаяСхема);

	ОписаниеДополнительныхСвойств =  ПроверяемаяСхема.Получить("additionalProperties");
	
	СписокСвойств = ПроверяемаяСхема.Получить("properties");
	Если СписокСвойств = Неопределено Тогда
		// Если свойства не определены - значит все свойства что есть, дополнительные.
		// Передадим пустое соответсвие в качестве контекста
		СписокСвойств = Новый Соответствие;
	КонецЕсли;
	Для Каждого Свойство Из ПроверяемоеЗначение Цикл
		ДополнитьАдресДанных(Свойство.Ключ);
		ПроверитьСвойствоПоСхеме(Свойство.Значение, Свойство.Ключ, СписокСвойств, ОписаниеДополнительныхСвойств);
		СократитьАдресДанных();
	КонецЦикла;
КонецПроцедуры

Процедура ПроверитьНаличиеОбязательныхСвойств(ПроверяемыйОбъект, ПроверяемаяСхема)
	МассивОбязательныхПараметров = ПроверяемаяСхема.Получить("required");
	Если МассивОбязательныхПараметров = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ИмяОбязательногоСвойства Из МассивОбязательныхПараметров Цикл
		ПроверитьНаличиеОбязательногоСвойстваПоИмени(ПроверяемыйОбъект, ИмяОбязательногоСвойства);
	КонецЦикла;
КонецПроцедуры

Процедура ПроверитьНаличиеОбязательногоСвойстваПоИмени(ПроверяемыйОбъект, ИмяОбязательногоСвойства)
    СвойствоНайдено = Ложь;
	Если ТипЗнч(ПроверяемыйОбъект) = Тип("Структура") Тогда
		СвойствоНайдено = ПроверяемыйОбъект.Свойство(ИмяОбязательногоСвойства);
	Иначе
		СвойствоНайдено = Не ПроверяемыйОбъект.Получить(ИмяОбязательногоСвойства) = Неопределено;
	КонецЕсли;
	Если СвойствоНайдено Тогда
		Возврат;
	КонецЕсли;
	
	ОшибкаОбъектНеСодержитОбязательноеСвойство(ИмяОбязательногоСвойства);
КонецПроцедуры

Процедура ПроверитьКоличествоСвойств(ПроверяемоеЗначение, ПроверяемаяСхема)
	КоличествоСвойств = ПроверяемоеЗначение.Количество();
	МинимумСвойств = ПроверяемаяСхема.Получить("minProperties");
	Если Не МинимумСвойств = Неопределено И КоличествоСвойств < МинимумСвойств Тогда
		ОшибкаОбъектСодержитМалоСвойств(КоличествоСвойств, МинимумСвойств);
		Возврат;
	КонецЕсли;
	
	МаксимумСвойств = ПроверяемаяСхема.Получить("maxProperties");
	Если Не МаксимумСвойств = Неопределено И КоличествоСвойств > МаксимумСвойств Тогда
		ОшибкаОбъектСодержитМногоСвойств(КоличествоСвойств, МаксимумСвойств);
		Возврат;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область АдресацияДанных
Процедура ИнициализироватьАдресДанных()
	ЧастиАдресаДанных = Новый Массив();
КонецПроцедуры

Процедура ДополнитьАдресДанных(ИмяПоля)
	ЧастиАдресаДанных.Добавить(ИмяПоля);
КонецПроцедуры

Процедура СократитьАдресДанных()
	ИндексПоследнего = ЧастиАдресаДанных.ВГраница();
	ЧастиАдресаДанных.Удалить(ИндексПоследнего);
КонецПроцедуры

Функция ПолныйАдресДанных()
	Возврат СтрСоединить(ЧастиАдресаДанных, ".");
КонецФункции

#КонецОбласти

Процедура ВалидироватьБулево(ПроверяемоеЗначение, ПроверяемаяСхема)  // BSLLS:Typo-off
	ОписаниеТипа = Новый ОписаниеТипов("Булево");
	
	ТипЗначенияСоответствуетОписанию(ПроверяемоеЗначение, ОписаниеТипа);
КонецПроцедуры

Процедура УстановитьШаблоныСообщений(Описание = "")
	Имя = ПолныйАдресДанных();
	Представление = СтрШаблон("<%1>", Имя);
	
	Если ЗначениеЗаполнено(Описание) Тогда
		Представление = СтрШаблон("<%1>(%2)", Имя, Описание);
	КонецЕсли;
	
	ШаблонБазовойОшибки = СтрШаблон("Ошибка валидации %1.", Представление);
	ШаблонПредупреждения = СтрШаблон("Проблема валидации %1.", Представление);
КонецПроцедуры

Функция ТипЗначенияСоответствуетОписанию(ПроверяемоеЗначение, ОписаниеТипа)

	ПриведенноеПроверяемоеЗначение = ОписаниеТипа.ПривестиЗначение(ПроверяемоеЗначение);
	
	ОжидаемыйТип = ТипЗнч(ПриведенноеПроверяемоеЗначение);
	ФактическийТип = ТипЗнч(ПроверяемоеЗначение);
	
	РазличаютсяТипы = ОжидаемыйТип <> ФактическийТип;
	
	Если РазличаютсяТипы Тогда
		ОшибкаЗначениеНедопустимогоТипа(ФактическийТип, ОписаниеТипа);
		Возврат Ложь;
	КонецЕсли;
	
	Если ПриведенноеПроверяемоеЗначение = ПроверяемоеЗначение Тогда
		// после приведения все совпадает. А значит тип подходит под схему.
		Возврат Истина;
	КонецЕсли;
		
	// Если мы здесь, значит отличаются Квалификаторы
	Если ФактическийТип = Тип("Дата") Тогда
		ОшибкаСтрокаНеСоответствуетФорматуДаты(ОписаниеТипа.КвалификаторыДаты.ЧастиДаты);
	ИначеЕсли ФактическийТип = Тип("Строка") Тогда
		ОшибкаСтрокаСлишкомДлинная(ОписаниеТипа.КвалификаторыСтроки.Длина);
	ИначеЕсли ФактическийТип = Тип("Число") Тогда
		ОшибкаЧислоНеЦелое();
	Иначе
		// Тут мы никогда не окажемся.
		ВызватьИсключение "При обработке схемы возникла исключительная ситуация!";
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

// Возвращает копию исходного массива с уникальными значениями.
//
// Параметры:
//  Массив - Массив - массив произвольных значений.
//
// Возвращаемое значение:
//  Массив - массив уникальных элементов.
//
Функция СвернутьМассив(Знач Массив)
	Результат = Новый Массив;
	ДополнитьМассив(Результат, Массив, Истина);
	Возврат Результат;
КонецФункции

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник - Массив - массив, в который необходимо добавить значения.
//  МассивИсточник - Массив - массив значений для заполнения.
//  ТолькоУникальныеЗначения - Булево - если истина, то в массив будут включены только уникальные значения.
//
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь)
	
	Если ТолькоУникальныеЗначения Тогда
		
		УникальныеЗначения = Новый Соответствие;
		
		Для Каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
		
		Для Каждого Значение Из МассивИсточник Цикл
			Если УникальныеЗначения[Значение] = Неопределено Тогда
				МассивПриемник.Добавить(Значение);
				УникальныеЗначения.Вставить(Значение, Истина);
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Для Каждого Значение Из МассивИсточник Цикл
			МассивПриемник.Добавить(Значение);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ДополнитьТаблицу(ТаблицаПриемник, ТаблицаИсточник)
	
	Для Каждого СтрокаИсточника Из ТаблицаИсточник Цикл
		
		СтрокаПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаПриемника, СтрокаИсточника);
		
	КонецЦикла;
		
КонецПроцедуры

Функция ПолучитьПроверяемуюСхему(ИмяСхемы, ТекущийКонтекст)
	ПроверяемаяСхема = ТекущийКонтекст.Получить(ИмяСхемы);
	
	Если ПроверяемаяСхема = Неопределено Тогда
		// Если у нас на вход неопределено, значит такая схема не найдена. 
		// Это нормально, в случае если это неизвестное свойство. просто больше ничего не делаем
		Возврат ПроверяемаяСхема;
	КонецЕсли;
	
	ПроверяемаяСхема = РазыменоватьСхему(ПроверяемаяСхема);
	
	Возврат ПроверяемаяСхема;
КонецФункции

// Функция - Разыменовать схему
// Обрабатывает переданную схему.
// Получает необходимую схему по ссылке, если это требуется.
// Параметры:
//  ПроверяемаяСхема - Соответствие - Схема которую требуется разыменовать
//
// Возвращаемое значение:
// Соответствие  - Разыменованое соответствие
//
Функция РазыменоватьСхему(ПроверяемаяСхема) Экспорт
	РазыменованнаяСхема = ПроверяемаяСхема;
	Если РазыменованнаяСхема = Неопределено Тогда
		// Если у нас на вход неопределено, значит такая схема не найдена. 
		// Это нормально, в случае если это неизвестное свойство. просто больше ничего не делаем
		Возврат РазыменованнаяСхема;
	КонецЕсли;
	
	СсылкаНаСхему = РазыменованнаяСхема.Получить("$ref");
	
	Если ЗначениеЗаполнено(СсылкаНаСхему) Тогда
		РазыменованнаяСхема = ВалидаторПакетовПовтИсп.СхемаПоСтроковомуПути(СсылкаНаСхему, Спецификация);
	КонецЕсли;
	
	Возврат РазыменованнаяСхема;
КонецФункции

// Функция - Это сложная схема
//
// Параметры:
//  ПроверяемаяСхема - Соответствие	- Описание проверяемой схемы 
// 
// Возвращаемое значение:
//  Булево - Истина, если схема использует сложные конструкции
//
Функция ЭтоСложнаяСхема(ПроверяемаяСхема) Экспорт
	ЭтоOneOf = ЕстьСвойство("oneOf", ПроверяемаяСхема);
	ЭтоAllOf = ЕстьСвойство("allOf", ПроверяемаяСхема);
	ЭтоAnyOf = ЕстьСвойство("anyOf", ПроверяемаяСхема);
	
	Возврат ЭтоOneOf Или ЭтоAllOf Или ЭтоAnyOf;
КонецФункции

Функция ЕстьСвойство(ИмяСвойства, ПроверяемаяСхема)
	Возврат Не ПроверяемаяСхема.Получить(ИмяСвойства) = Неопределено;
КонецФункции

// Возвращает список ошибок модели данных.
// 
// Возвращаемое значение:
//  Структура - Структура результата валидации.
Функция КонструкторРезультатВалидации()
	Ошибки = НоваяКоллекцияДиагностик();
	
	Возврат Новый Структура("Результат, Ошибки", Истина, Ошибки);
	
КонецФункции

#Область Диагностики

// Интерфейс работы с коллекцией ошибок

Функция НоваяКоллекцияДиагностик()
	
	Коллекция = Новый ТаблицаЗначений();
	
	Коллекция.Колонки.Добавить("КодОшибки", Новый ОписаниеТипов("Строка"));
	Коллекция.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Массив"));
	Коллекция.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));
	Коллекция.Колонки.Добавить("Предупреждение", Новый ОписаниеТипов("Булево"));
	Коллекция.Колонки.Добавить("ДополнительныеПараметры", Новый ОписаниеТипов("Структура"));
	
	Возврат Коллекция;
		
КонецФункции

Функция ДобавитьДиагностикуВКоллекцию(КодОшибки, ТекстОшибки, ДополнительныеПараметры = Неопределено)
	
	НоваяДиагностика = Ошибки.Добавить();
	
	НоваяДиагностика.КодОшибки = КодОшибки;
	НоваяДиагностика.Представление = ТекстОшибки;
	
	ДополнитьМассив(НоваяДиагностика.Позиция, ЧастиАдресаДанных);
	
	Если ДополнительныеПараметры <> Неопределено Тогда
		НоваяДиагностика.ДополнительныеПараметры = ДополнительныеПараметры;
	КонецЕсли;
	
	Возврат НоваяДиагностика;
	
КонецФункции

Функция ДобавитьОшибкуВКоллекцию(КодОшибки, ТекстОшибки, ДополнительныеПараметры = Неопределено)
	
	ПредставлениеОшибки = ШаблонБазовойОшибки + " " + ТекстОшибки;
	
	НоваяДиагностика = ДобавитьДиагностикуВКоллекцию(КодОшибки, ПредставлениеОшибки, ДополнительныеПараметры);
	
	Возврат НоваяДиагностика;
		
КонецФункции

Функция ДобавитьПредупреждениеВКоллекцию(КодОшибки, ТекстПредупреждения, ДополнительныеПараметры = Неопределено)
	
	ПредставлениеПредупреждения = ШаблонПредупреждения + " " + ТекстПредупреждения;
	
	НоваяДиагностика = ДобавитьДиагностикуВКоллекцию(КодОшибки, ПредставлениеПредупреждения, ДополнительныеПараметры);
	НоваяДиагностика.Предупреждение = Истина;
	
	Возврат НоваяДиагностика;
	
КонецФункции

Функция КоллекцияОшибокПустая()
	
	Отбор = Новый Структура("Предупреждение", Ложь);
	НайденныеОшибки = Ошибки.НайтиСтроки(Отбор);
	
	Возврат НайденныеОшибки.Количество() = 0;
	
КонецФункции

Функция СпрятатьДиагностики()
	
	Заначка = НоваяКоллекцияДиагностик();
	
	ДополнитьТаблицу(Заначка, Ошибки);
	
	ОчиститьКоллекциюДиагностик();
	
	Возврат Заначка;
	
КонецФункции

Процедура ВосстановитьДиагностики(Заначка)
	
	ДополнитьТаблицу(Ошибки, Заначка);
	
КонецПроцедуры

Процедура ОчиститьКоллекциюДиагностик()
	
	Ошибки.Очистить();
	
КонецПроцедуры

// Ошибки при проверке свойств объекта

Процедура ОшибкаОбъектНеДопускаетДополнительныхСвойств(ИмяСвойства)
	
	ТекстОшибки = СтрШаблон("Не удалось найти свойство <%1> в схеме данных;",
		ИмяСвойства);
	ДобавитьОшибкуВКоллекцию("AdditionalPropertiesNotAllowed",
		ТекстОшибки,
		Новый Структура("ИмяСвойства", ИмяСвойства));

КонецПроцедуры

Процедура ОшибкаОбъектНеСодержитОбязательноеСвойство(ИмяСвойства)
	
	ТекстОшибки = СтрШаблон("Отсутствует обязательное свойство <%1>;",
		ИмяСвойства);
	ДобавитьОшибкуВКоллекцию("MissingRequiredProperty",
		ТекстОшибки,
		Новый Структура("ИмяСвойства", ИмяСвойства));

КонецПроцедуры

Процедура ОшибкаОбъектСодержитМалоСвойств(КоличествоСвойств, МинимумСвойств)
	
	ТекстОшибки = СтрШаблон("Количество свойств объекта <%1> меньше минимального порога <%2>;",
		КоличествоСвойств,
		МинимумСвойств);
	ДобавитьОшибкуВКоллекцию("MinimumPropertiesRequired",
		ТекстОшибки,
		Новый Структура("КоличествоСвойств", КоличествоСвойств));

КонецПроцедуры

Процедура ОшибкаОбъектСодержитМногоСвойств(КоличествоСвойств, МаксимумСвойств)
	
	ТекстОшибки = СтрШаблон("Количество свойств объекта <%1> больше максимального порога <%2>;",
		КоличествоСвойств,
		МаксимумСвойств);
	ДобавитьОшибкуВКоллекцию("MaximumPropertiesRequired",
		ТекстОшибки,
		Новый Структура("КоличествоСвойств", КоличествоСвойств));

КонецПроцедуры

Процедура ОшибкаОбъектСодержитУстаревшееСвойство()
	
	ТекстПредупреждения = "Свойство признано устаревшим! Необходимо отказаться от использования в кратчайшее время.";
	ДобавитьПредупреждениеВКоллекцию("DeprecatedProperty",
		ТекстПредупреждения);

КонецПроцедуры

// Ошибки при проверке элементов массива

Процедура ОшибкаМассивСлишкомКороткий(ПроверяемыйМассив, МинимумСтрок)
	
	ТекстОшибки = СтрШаблон("Количество элементов массива <%1> меньше минимального порога <%2>;",
		ПроверяемыйМассив.Количество(),
		МинимумСтрок);
	ДобавитьОшибкуВКоллекцию("MinimumArrayElementsRequired",
		ТекстОшибки,
		Новый Структура("КоличествоЭлементов", ПроверяемыйМассив.Количество()));

КонецПроцедуры

Процедура ОшибкаМассивСлишкомДлинный(ПроверяемыйМассив, МаксимумСтрок)
	
	ТекстОшибки = СтрШаблон("Количество элементов массива <%1> больше максимального порога <%2>;",
		ПроверяемыйМассив.Количество(),
		МаксимумСтрок);
	ДобавитьОшибкуВКоллекцию("MaximumArrayElementsRequired",
		ТекстОшибки,
		Новый Структура("КоличествоЭлементов", ПроверяемыйМассив.Количество()));

КонецПроцедуры

Процедура ОшибкаМассивСНеуникальнымиЭлементами()
	
	ТекстОшибки = СтрШаблон("Значения в массиве не уникальны;");
	ДобавитьОшибкуВКоллекцию("NonUniqueArrayElements",
		ТекстОшибки);

КонецПроцедуры

// Общие ошибки при проверке примитивных значений

Процедура ОшибкаЗначениеНеМожетБытьNull(ИмяСвойства)
	
	ТекстОшибки = СтрШаблон("Свойство <%1> объявлено, и должно быть заполнено, но это не так;",
		ИмяСвойства);
	ДобавитьОшибкуВКоллекцию("NullPropertyValue",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаЗначениеНедопустимогоТипа(ФактическийТип, ОписаниеОжидаемогоТипа)
	
	ПредставлениеОжидаемыхТипов = СтрСоединить(ОписаниеОжидаемогоТипа.Типы(), "; ");
	ТекстОшибки = СтрШаблон("Передан тип <%1>. Список допустимых типов: <%2>;",
		ФактическийТип,
		ПредставлениеОжидаемыхТипов);
	ДобавитьОшибкуВКоллекцию("InvalidType",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаЗначениеНеИзСпискаДопустимых(ПроверяемоеЗначение, ДопустимыеЗначения)
	
	ПредставлениеПеречисления = СтрСоединить(ДопустимыеЗначения, ";");
	ТекстОшибки = СтрШаблон("Значение <%1> не найдено среди доступных вариантов. Список доступных значений: <%2>;",
		ПроверяемоеЗначение,
		ПредставлениеПеречисления);
	ДобавитьОшибкуВКоллекцию("InvalidEnumValue",
		ТекстОшибки);

КонецПроцедуры

// Ошибки проверки строк

Процедура ОшибкаСтрокаНеBase64()
	
	ТекстОшибки = СтрШаблон("Ожидалось Base64 значение;");
	ДобавитьОшибкуВКоллекцию("InvalidBase64String",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаСтрокаСлишкомКороткая(МинимальнаяДлина)
	
	ТекстОшибки = СтрШаблон("Длина, меньше требуемой. Минимальная длина <%1>;",
		МинимальнаяДлина);
	ДобавитьОшибкуВКоллекцию("MinLengthRequired",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаСтрокаСлишкомДлинная(МаксимальнаяДлина)
	
	ТекстОшибки = СтрШаблон("Длина строки превышает максимальную. Максимальная длина <%1>;",
		МаксимальнаяДлина);
	ДобавитьОшибкуВКоллекцию("MaxLengthRequired",
		ТекстОшибки);
								
КонецПроцедуры

Процедура ОшибкаСтрокаНеСоответствуетФорматуДаты(ОписаниеЧастиДаты)
	
	ТекстОшибки = СтрШаблон("Неверный формат даты. Ожидается строка в формате <%1>;",
		ОписаниеЧастиДаты);
	ДобавитьОшибкуВКоллекцию("InvalidDateFormat",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаСтрокаНеСоответствуетШаблону(Шаблон)
	
	ТекстОшибки = СтрШаблон("Ожидался формат %1;",
		Шаблон);
	ДобавитьОшибкуВКоллекцию("InvalidFormat",
		ТекстОшибки);

КонецПроцедуры

// Ошибки проверки чисел

Процедура ОшибкаЧислоСлишкомМало(ПроверяемоеЗначение, МинимальноеЗначение, Включая)
	
	ТекстОшибки = СтрШаблон("Значение <%1> должно быть больше %2<%3>;",
		ПроверяемоеЗначение,
		?(Включая, "или равно ", ""),
		МинимальноеЗначение);
	ДобавитьОшибкуВКоллекцию("MinValueRequired",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаЧислоСлишкомБольшое(ПроверяемоеЗначение, МаксимальноеЗначение, Включая)
	
	ТекстОшибки = СтрШаблон("Значение <%1> должно быть меньше %2<%3>;",
		ПроверяемоеЗначение,
		?(Включая, "или равно ", ""),
		МаксимальноеЗначение);
	ДобавитьОшибкуВКоллекцию("MaxValueRequired",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаЧислоНеКратно(ПроверяемоеЗначение, Кратность)
	
	ТекстОшибки = СтрШаблон("Значение <%1> должно быть кратно <%2>;",
		ПроверяемоеЗначение,
		Кратность);
	ДобавитьОшибкуВКоллекцию("NonDivisible",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаЧислоНе32Битное(ПроверяемоеЗначение)
	
	ТекстОшибки = СтрШаблон("Некорректный формат значения, число должно быть 32-битным целым;");
	ДобавитьОшибкуВКоллекцию("InvalidInt32",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаЧислоНе64Битное(ПроверяемоеЗначение)
	
	ТекстОшибки = СтрШаблон("Некорректный формат значения, число должно быть 64-битным целым;");
	ДобавитьОшибкуВКоллекцию("InvalidInt64",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаЧислоНеЦелое()
	
	ТекстОшибки = СтрШаблон("Некорректный формат значения, число должно быть целым;");
	ДобавитьОшибкуВКоллекцию("NoneInteger",
		ТекстОшибки);
								
КонецПроцедуры

// Ошибки проверки сложных схем

Процедура ОшибкаСоответствиеНесколькимСхемамOneOf(ПрошедшиеВалидацию)
	
	ТекстОшибки = СтрШаблон("<oneOf> Объект должен соответствовать только одной схеме. Индексы валидных схем <%1>;",
		СтрСоединить(ПрошедшиеВалидацию, ";"));
	ДобавитьОшибкуВКоллекцию("MultipleOneOfSchemaMatch",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаНесоответствиеСхемамOneOf()
	
	ТекстОшибки = СтрШаблон("<oneOf> Объект должен соответствовать хотя бы одной схеме;");
	ДобавитьОшибкуВКоллекцию("OneOfSchemaMismatch",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаНесоответствиеСхемамAnyOf()

	ТекстОшибки = СтрШаблон("<anyOf> Объект должен соответствовать хотя бы одной схеме;");
	ДобавитьОшибкуВКоллекцию("AnyOfSchemaMismatch",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаНесоответствиеСхемамAllOf()
	
	ТекстОшибки = СтрШаблон("<allOf> Объект должен соответствовать всем схемам.");
	ДобавитьОшибкуВКоллекцию("AllOfSchemaMismatch",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаНесоответствиеСхемеNot()
	
	ТекстОшибки = СтрШаблон("<not> Объект не должен соответствовать схеме, а он соответствует;");
	ДобавитьОшибкуВКоллекцию("NotSchemaMismatch",
		ТекстОшибки);

КонецПроцедуры

Процедура ОшибкаНетЗначенияДискриминатора(ИмяСвойства)
	
	ТекстОшибки = СтрШаблон("<discriminator> ключевое свойство <%1> Должно существовать и быть заполнено;",
		ИмяСвойства);
	ДобавитьОшибкуВКоллекцию("MissingRequiredDiscriminatorProperty",
		ТекстОшибки,
		Новый Структура("ИмяСвойства", ИмяСвойства));

КонецПроцедуры

#КонецОбласти

#КонецОбласти
#КонецЕсли
